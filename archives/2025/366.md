---
title: 联合类型与交叉类型的反直觉
number: '#366'
link: 'https://github.com/toFrankie/blog/issues/366'
created_at: '2025-08-29 12:01:27'
updated_at: '2025-08-29 18:28:00'
labels:
  - TS
  - '2025'
---
## 前言

- 联合类型：要么 A，要么 B（只要满足任意一个分支）
- 交叉类型：必须同时满足 A 和 B（必须满足所有分支）

```ts
type Union = A | B

type Intersection = A & B
```

看起来，联合类型像数学上的“并集”，交叉类型像“交集”。

## 符合直觉

▼ 要么是字符串，要么是数字，这是符合直觉的。

```ts
type DataUnion = string | number

let data: DataUnion

data = 'abc' // ✅
data = 123 // ✅
```
▼ 由于不可能存在同时满足是字符串，也是数字的值，因此 `DataIntersection` 类型是 `never`。这也是符合直觉的。

```ts
type DataIntersection = string & number

let data: DataIntersection

data = 'abc' // ❌ Type '"abc"' is not assignable to type 'never'.
data = 123 // ❌ Type '123' is not assignable to type 'never'.
```

▼ 以下为对象类型，Shape 应该保持一致，是符合直觉的。

```ts
type Point = { x: number }

let p: Point

p = { x: 1 } // ✅
p = { y: 2 } // ❌ Object literal may only specify known properties, and 'y' does not exist in type 'Point'.
p = { x: 1, y: 2 } // ❌ Object literal may only specify known properties, and 'y' does not exist in type 'Point'.
```

▼ 以下为对象的交叉类型，要符合「必须同时满足 A 和 B」结论，其结果必须是一个包含 `x` 和 `y` 属性新对象类型，是符合直觉的。

```ts
type PointIntersection = { x: number } & { y: number }

let p: PointIntersection

p = { x: 1 } // ❌ Property 'y' is missing in type '{ x: number; }' but required in type '{ y: number; }'.
p = { y: 2 } // ❌ Property 'x' is missing in type '{ y: number; }' but required in type '{ x: number; }'.
p = { x: 1, y: 2 } // ✅
p = { x: 1, y: 2, z: 3 } // ❌ Object literal may only specify known properties, and 'z' does not exist in type 'PointIntersection'.
```

▼ 以下示例访问属性 `point.x`、`point.y` 报错是符合直觉的，一个没有 `x`、一个没有 `y`。TypeScript 会要求所有成员类型里都保证存在的属性，才允许安全访问。该方法的修正方式是做类型收窄。

```ts
type PointUnion = { x: number } | { y: number }

function showPoint(point: PointUnion) {
  const x = point.x ?? 0 // ❌ Property 'x' does not exist on type '{ y: number; }'.
  const y = point.y ?? 0 // ❌ Property 'y' does not exist on type '{ x: number; }'.
  return `(${x}, ${y})`
}
```

## 反直觉

▼ 以下示例，按理 `p = obj` 报错才是符合直觉的。

```ts
type Point = { x: number }

let p: Point

let obj = { x: 1, y: 2 }

p = { x: 1, y: 2 } // ❌ Object literal may only specify known properties, and 'y' does not exist in type 'Point'.
p = obj // ✅
```

原因如下：
1. 如果赋值语句等号右边是一个字面量，会触发对象的严格字面量检查（strict object literal checking）。因此多了未定义的属性 `y` 会报错。
2. 如果赋值语句等号右边是一个变量，则不会触发对象的严格字面量检查，所以多了属性没报错（但不能少）。尽管赋值的 `obj` 是包含 `y` 属性的，但通过 `p.y` 访问属性仍然会报错，因为 `p` 的类型 `Point` 并不包含 `y` 属性。

> 对于 `p = obj` 这类不触发严格字面量检查，是有实际意义的。比如接口的返回数据有 N 多字段，但业务上实际用到可能只有其中一部分，这种情况下只需声明用到的字段即可。


▼ 以下示例，为什么 `p = { x: 1, y: 2 }` 又不报错？

```ts
type PointUnion = { x: number } | { y: number }

let p: PointUnion

p = { x: 1 } // ✅
p = { y: 2 } // ✅
p = { x: 1, y: 2 } // ✅ 明明是字面量，又不报错了？？？
```

原因是触发对象的严格字面量检查，有两个要求：
1. 赋值语句等号右边是一个字面量
2. 被赋值对象的类型是单一的对象类型（非联合、非索引签名）

▼ 再看示例，原因跟前面一样，就是看起来有点奇怪。

```
type PointUnion = { x: number } | { y: number }
type PointIntersection = { x: number } & { y: number }

let point1: PointUnion
let point2: PointIntersection

point1 = { x: 1, y: 2 } // ✅
point2 = { x: 1, y: 2 } // ✅
```
