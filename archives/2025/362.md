---
title: CSS 中 display、opacity 、visibility 的区别
number: '#362'
link: 'https://github.com/toFrankie/blog/issues/362'
created_at: '2025-06-14 14:12:51'
updated_at: '2025-09-03 16:32:29'
labels:
  - CSS
  - 前端
  - '2025'
---
![配图源自 Freepik](https://cdn.jsdelivr.net/gh/toFrankie/blog@main/images/2025/6/1750006164441.jpg)

用 CSS 使元素在视觉上不可见，我们通常会想到以下几种属性：

- `display: none`
- `opacity: 0`
- `visibility: hidden`

尽管这些属性都能使元素不可见，但它们之间仍存在明显差异！

## 基本概念

- `display: none`：元素完全从文档流中移除，不占据任何空间，不可见且不响应事件。
- `opacity: 0`：元素在视觉上不可见，但仍占据原有空间，可以响应事件。
- `visibility: hidden`：元素在视觉上不可见，占据原有空间，但不响应事件。

## 直观对比

### 是否占据布局空间

| 属性 | 占据空间 | 说明 |
| --- | --- | --- |
| `display: none`      | ❌           | 元素从文档流中完全移除   |
| `opacity: 0`         | ✅           | 元素仍占据原有位置和尺寸 |
| `visibility: hidden` | ✅           | 元素仍占据原有位置和尺寸 |

### 是否响应事件

| 属性 | 元素本身 | 子元素 | 说明 |
| --- | --- | --- | --- |
| `display: none`      | ❌ | ❌ | 元素及其后代均不响应事件 |
| `opacity: 0`         | ✅ | ✅ | 无论是否可见，均可响应事件 |
| `visibility: hidden` | ❌ | 取决于子元素设置 | 子元素可设置为 `visible` 来响应事件 |

> [CodePen 示例](https://codepen.io/tofrankie/pen/bNVmyby)（元素本身）

> [CodePen 示例](https://codepen.io/tofrankie/pen/qEOJGOV)（子元素）

### 是否支持过渡动画

| 属性         | 支持过渡动画 | 说明                                      |
| ------------ | ------------ | ----------------------------------------- |
| `display`    | ❌           | 无法在 `none` 和 `block` 之间平滑过渡     |
| `opacity`    | ✅           | 可以在 0 ~ 1 之间平滑过渡                |
| `visibility` | ❌           | 无法在 `visible` 和 `hidden` 之间平滑过渡 |

> [CodePen 示例](https://codepen.io/tofrankie/pen/gbaZaOV)

### 外设访问性

| 属性                 | 屏幕阅读器 | 键盘导航 | 说明                       |
| -------------------- | ---------- | -------- | -------------------------- |
| `display: none`      | ❌         | ❌       | 元素完全从可访问性树中移除 |
| `opacity: 0`         | ✅         | ✅       | 元素仍存在于可访问性树中   |
| `visibility: hidden` | ✅         | ✅       | 元素仍存在于可访问性树中   |

## 原因分析

为了理解为什么会有这些差异，我们需要了解浏览器的渲染流程。

### 页面生成过程

1. 解析 HTML 构建 DOM Tree
2. 解析 CSS 构建 CSSOM Tree
3. 将 DOM 和 CSSOM 合并生成渲染树（Render Tree）
4. Layout 阶段，根据渲染树计算每个节点的位置和尺寸
5. Painting 阶段，将各个节点绘制到屏幕上

### 渲染树生成过程

![](https://cdn.jsdelivr.net/gh/toFrankie/blog@main/images/2025/6/1750002005031.png)

1. 从根节点开始，遍历每个可见节点。
    1. 某些不可见节点（如 head、script、link、meta 等标签），它们会被忽略。
    2. 一些使用 CSS 属性隐藏（`display: none`）的节点，也会被忽略。
2. 对于每个可见节点，找到其匹配的 CSSOM 规则并应用。
3. 最终形成带有内容及计算样式的可见节点。

> 注意，虽然 `display: none` 的元素不会进入渲染树，但仍然可以使用 JS 操作该元素。原因是 JS 操作的是 DOM 树，而不是渲染树。

关键差异：

- `display: none` 的元素不会进入渲染树，因此不参与后续的布局和绘制
- `opacity: 0` 和 `visibility: hidden` 的元素会进入渲染树，参与布局计算

### Layout 和 Painting 阶段

- Layout 阶段：计算元素的确切位置和大小，回流发生在此阶段。
- Painting 阶段：将元素转换为屏幕像素，重绘发生在此阶段。

### 回流与重绘的关系

- 有回流一定伴随着重绘
- 发生重绘不一定伴随着回流

### 为什么会产生不同表现？

基于渲染流程：

1. **`display: none` 产生回流的原因：** 元素不进入渲染树，导致其他元素重新计算位置和尺寸
2. **`opacity: 0` 和 `visibility: hidden` 不产生回流的原因：** 元素仍占据原有空间，不影响其他元素的布局

## 继承性与子元素表现

### CSS 继承性

| 属性           | 是否为继承属性 | 初始值              | 说明                 |
| -------------- | -------- | ------------------- | -------------------- |
| **display**    | ❌       | `inline` 或 `block` | 取决于元素类型       |
| **opacity**    | ❌       | `1`                 | 子元素默认不透明     |
| **visibility** | ✅       | `visible`           | 子元素默认继承父元素的值 |

### 子元素可见性分析

当父元素设置不同属性时，子元素的表现：

情况一：子元素使用默认值

| 父元素设置           | 子元素默认值         | 子元素最终表现       | 结果                      |
| -------------------- | -------------------- | -------------------- | ------------------------- |
| `display: none`      | `display: block`     | `display: block`     | ❌ 父元素不在渲染树中，均不可见 |
| `opacity: 0`         | `opacity: 1`         | `opacity: 1`         | ❌ 受父元素影响，均不可见 |
| `visibility: hidden` | `visibility: hidden` | `visibility: hidden` | ❌ 受父元素影响，均不可见 |

情况二：子元素主动设置

| 父元素设置           | 子元素设置         | 结果                      |
| -------------------- | -------------------- | ------------------------- |
| `display: none`      | `display: block`     | ❌ 父元素不在渲染树中，均不可见 |
| `opacity: 0`         | `opacity: 1`         | ❌ 受父元素影响，均不可见 |
| `visibility: hidden` | `visibility: visible`| ✅ 不受父元素影响，父元素不可见，子元素可见 |

> visibility 的特殊性：子元素可以设置为 `visibility: visible` 来摆脱父元素的影响。

### 子元素事件响应分析


| 父元素设置           | 子元素设置            | 子元素可见性 | 子元素事件响应 | 说明                       |
| -------------------- | --------------------- | ------------ | -------------- | -------------------------- |
| `display: none`      | 任何值                | ❌           | ❌             | 父元素不在渲染树中         |
| `opacity: 0`         | 任何值          | ❌           | ✅             | 仅视觉上不可见 |
| `visibility: hidden` | `visibility: visible` | ✅           | ✅             | 子元素摆脱父元素影响       |

## 实际应用建议

### 何时使用 display: none

适用场景：

- 需要完全移除元素，不占用任何空间
- 元素及其后代都不需要响应事件
- 不需要考虑可访问性

注意事项：

- 会产生回流，影响性能
- 无法通过过渡动画实现平滑效果

### 何时使用 opacity: 0

适用场景：

- 需要平滑的淡入淡出效果
- 元素需要响应事件（如悬停效果）
- 需要保持布局稳定

注意事项：

- 元素仍占据空间
- 子元素也会不可见

### 何时使用 visibility: hidden

适用场景：

- 需要保持布局稳定
- 子元素需要可见或响应事件
- 需要良好的可访问性支持

注意事项：

- 元素仍占据空间
- 不支持过渡动画
- 子元素可以通过设置 `visibility: visible` 来摆脱影响

### 选择指南总结

| 需求                   | 推荐属性                             | 原因                             |
| ---------------------- | ------------------------------------ | -------------------------------- |
| 完全隐藏元素，不占空间 | `display: none`                      | 元素不进入渲染树，不参与布局计算 |
| 平滑的淡入淡出效果     | `opacity: 0`                         | 支持过渡动画                     |
| 保持布局，子元素可见   | `visibility: hidden`                 | 子元素可设置为 `visible`         |
| 隐藏但保持事件响应     | `opacity: 0`                         | 元素仍存在于 DOM 中              |
| 性能优先，避免回流     | `opacity: 0` 或 `visibility: hidden` | 不产生回流                       |

## 总结

对比之下：

1. **`display: none`** 适合完全移除元素的场景，但会产生回流
2. **`opacity: 0`** 适合需要平滑动画和事件响应的场景
3. **`visibility: hidden`** 适合需要保持布局和灵活控制子元素的场景
