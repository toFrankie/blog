---
title: CSS 中 display、opacity 、visibility 的区别
number: '#362'
link: 'https://github.com/toFrankie/blog/issues/362'
created_at: '2025-06-14 14:12:51'
updated_at: '2025-09-03 15:01:48'
labels:
  - CSS
  - 前端
  - '2025'
---

![配图源自 Freepik](https://cdn.jsdelivr.net/gh/toFrankie/blog@main/images/2025/6/1750006164441.jpg)

用 CSS 使元素在视觉上不可见，我们通常会想到以下几种属性：

- `display: none`
- `opacity: 0`
- `visibility: hidden`

尽管这些属性都能使元素不可见，但它们之间仍存在明显差异！

## 开始之前

### 页面生成过程

1. 解析 HTML 构建 DOM Tree。
2. 解析 CSS 构建 CSSOM Tree。
3. 将 DOM 和 CSSOM 合并生成渲染树（Render Tree）。
4. Layout 阶段，根据渲染树计算每个节点的位置和尺寸。
5. Painting 阶段，将各个节点绘制到屏幕上。

### 渲染树生成过程

![](https://cdn.jsdelivr.net/gh/toFrankie/blog@main/images/2025/6/1750002005031.png)

1. 从根节点开始，遍历每个可见节点。
    1. 某些不可见节点（如 head、script、link、meta 等标签），它们会被忽略。
    2. 一些使用 CSS 属性隐藏（`display: none`）的节点，也会被忽略。
2. 对于每个可见节点，找到其匹配的 CSSOM 规则并应用。
3. 最终形成带有内容及计算样式的可见节点。

> 注意，应用了 `opacity: 0` 和 `visibility: hidden` 的节点，此过程中不会被忽略。

### Layout 阶段

前面的过程得到了渲染树，它包含了屏幕上所有可见节点的内容和样式信息。

进入 Layout 阶段后，浏览器会从渲染树的根开始遍历，输出一个包括了每个元素确切位置和大小的盒子模型（Box Model）。

回流发生在此阶段。任何影响节点尺寸、位置的更改（如字号、display、文档结构等）都可能会触发。

### Painting 阶段

该阶段将渲染树中的每个节点转换为屏幕上的实际像素。

重绘发生在此阶段。外观样式更改（如果颜色、透明度等）会触发。

### 回流与重绘关系

根据两个阶段的先后关系，明显可知：

- 有回流一定伴随着重绘。
- 发生重绘不一定伴随着回流。

## 是否占据布局空间

- `display: none` 会使得元素从文档流中移除，不占据任何页面空间。
- `opacity: 0` 和 `visibility: hidden` 仍会占据原有空间。

## 是否产生回流

- `display: none` 会产生回流。
- `opacity: 0` 和 `visibility: hidden` 不会产生回流。

前者由于不进入渲染树，会使得其他元素发生布局上的变化，因此会发生回流。而后两者仍占据着原有的位置，自然不会产生回流。

## 是否产生重绘

`display: none`、`opacity: 0` 和 `visibility: hidden` 都会产生重绘。

## 外设访问性

> 如键盘、屏幕阅读器等外设。

- `display: none` 不能被访问。
- `opacity: 0` 和 `visibility: hidden` 可以被访问。

## CSS 继承性

- **display** - 非继承属性，初始值 `inline` 或 `block`，取决于元素。
- **opacity** - 非继承属性，初始值为 `1`。
- **visibility** - 是继承属性，初始值为 `visible`。

## 子元素是否可见（指视觉上）

在父元素上分别设置：

- `display: none`
- `opacity: 0`
- `visibility: hidden`

根据其继承性、初始值，则子元素分别为：

- `display: block`（以 div 为例）
- `opacity: 1`
- `visibility: hidden`

结果是三者的子元素均不可见。

由于 visibility 会继承父元素的值，如果将子元素主动设为 `visibility: visible` 结果有何不同呢？

> 结果是 `visibility: visible` 的子元素可见。

结论：

- 若父元素为 `display: none`，子元素及后代不可见。
- 若父元素为 `opacity: 0`，子元素及后代不可见。
- 若父元素为 `visibility: hidden`、子元素为 `visibility: hidden`，子元素不可见。
- 若父元素为 `visibility: hidden`、子元素为 `visibility: visible`，子元素可见。

## 是否响应事件

分为：

- 元素本身（父元素）是否响应事件？
- 子元素是否响应事件？

在元素本身上分别设置：

- `display: none`
- `opacity: 0`
- `visibility: hidden`

### 元素本身

- 若元素为 `display: none`，则不响应事件。
- 若元素为 `opacity: 0`，则响应事件。
- 若元素为 `visibility: hidden`，则不响应事件。

> [CodePen 示例](https://codepen.io/tofrankie/pen/bNVmyby)

### 子元素

根据其继承性、初始值，则子元素分别为：

- `display: block`（以 div 为例）
- `opacity: 1`
- `visibility: hidden`

此时只有 `opacity: 1` 的子元素会响应事件，另外两个不响应事件。

> [CodePen 示例](https://codepen.io/tofrankie/pen/qEOJGOV)

接着将子元素分别设置：

- `display: none`
- `opacity: 0`
- `visibility: visible`

结果是 `opacity: 0` 和 `visibility: visible` 可响应事件，另外一个不响应事件。

- `display: none` 不会响应子元素的事件。
- `opacity: 0` 会响应子元素的事件。
- `visibility: hidden` 不会响应子元素的事件。

### 结论

- 若元素为 `display: none`，则本身及其后代元素的事件均不响应。
- 若元素为 `opacity: 0`，无论本身及其后代元素是否可见，均可响应事件。
- 若元素为 `visibility: hidden`，则元素本身事件不响应。
- 若元素为 `visibility: hidden`，子元素为 `visibility: visible`，则子元素事件可响应。

现在结合可见性、事件响应：

- 对于 `display: none` 的元素来说，它（包括后代元素）在构建 Render Tree 的阶段已经被忽略掉，因此它实际上并没有出现在 DOM 中，自然不可见，且不响应事件。
- 对于 `opacity: 0` 的元素来说，它只是视觉上的不可见，但元素是真实存在的，因此可响应事件。
- 对于 `visibility` 的元素来说，元素可见方能响应事件。比较特别的是，子元素可以摆脱父元素影响。可以设置为父元素不可见（`visibility: hidden`）同时子元素可见（`visibility: visible`）。对于公众号图文这种纯 CSS 交互的项目，借助该特性可以做出很多交互。

## 是否可用过渡动画

设置对应的 transition，切换 none «» block、0 «» 1、visible «» hidden，验证是否有过渡动画效果。结果如下：

- `display` 不支持过渡动画。
- `opacity` 支持过渡动画。
- `visibility` 不支持过渡动画。

> [CodePen 示例](https://codepen.io/tofrankie/pen/gbaZaOV)

未完待续...
