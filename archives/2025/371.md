---
title: 浅谈 TypeScript 泛型
number: '#371'
link: 'https://github.com/toFrankie/blog/issues/371'
created_at: '2025-09-09 18:28:15'
updated_at: '2025-09-14 17:32:29'
labels:
  - TS
  - '2025'
---
![配图源自 Freepik](https://cdn.jsdelivr.net/gh/toFrankie/blog@main/images/2025/9/1757842318229.jpg)

假设现在需要给 `id` 函数标注类型，它接收任意类型的参数并原样返回。

```js
function id(arg) {
  return arg
}
```

如何描述参数与返回值的类型关系呢？

较笨的做法是使用函数重载把可能的类型都列出来，但这样写下去，没写完就下班了...

```ts
function id(arg: number): number
function id(arg: string): string
function id(arg: boolean): boolean
// ...
```

类型可以有无数种（包括复合类型、联合类型等），根本穷举不完。

如果希望类型足够灵活，这也不是一种合理的做法。

我们知道，参数 `arg` 的具体值只有在函数调用时才能确认，参数类型也是同样的。

TS 的类型也是支持函数编程的，伪代码如下：

```ts
function Id(Arg) {
  return Arg
}
```

把类型函数化，也就是说 `Arg` 类型取决于函数调用时入参的类型。比如，当输入为 `string` 类型，输出也是 `string` 类型。

但这样写跟 JS 的函数语法有冲突，实际会被当作一个名为 `Id` 的 JS 函数。

TS 需要使用特有的语法来表达类型函数，用的是 `<>`，类似于 JS 函数的 `()`，在其内部声明类型的形参、函数的形参，伪代码如下：

```js
// 伪代码
function Id<Arg> {
  return Arg
}
```

> 历史故事：由于 TS 比 React 早出生，刚开始 TS 跟 JSX 的 `<>` 语法是有冲突的，直到 [TS 1.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html) 才开始支持 JSX。

前面都是伪代码，最后 TS 是这么干的，它把类型函数和函数本身融合在一起，语法如下：

> ⚠️ 注意，「类型函数」只是本文为了让读者更好地理解泛型而使用的一种表述，并非官方定术语。

```ts
function id<Arg>(arg: Arg): Arg {
  return arg
}
```

我们可以这样去解读：

1. 它是由函数本身和类型函数两部分组成。
2. 函数本身和类型函数都可以定义形参，分别在 `()`、`<>` 内定义。
3. 类型函数的形参在 `<>` 内定义，其作用范围（即函数体）是函数本身的形参类型和返回值类型。
4. 因为形参本身也算是一种变量，所以形参的 `Arg` 可以命名为其他合法的变量名。习惯上，`T`（Type）及其后面的字母 `U`、`V` 用得较多，类似于循环遍历常用的 i、j、k 差不多，算是一种约定俗成的写法吧。

使用更广泛的 `T` 替换 `Arg`，是不是很眼熟：

```ts
function id<T>(arg: T): T {
  return arg
}
```

得益于 TS 强大的自动类型推断，这个例子中不显式指定返回值类型也是 OK 的，它可以自动识别返回类型就是 `T`。

```ts
function id<T>(arg: T) {
  return arg
}
```

函数调用，这样传递类型参数：

```ts
id<string>('abc')
id<number>(1)
```

同样地，利用 TS 的类型推断，可以省略调用时 `<>` 类型：

```ts
id('abc')
id(1)
```

以上就是泛型在函数中的应用。

## 基础语法

前面我们将泛型“函数化”，实际上它也是支持定义多个类型参数、以及类型参数默认值的。

多个泛型参数：

```ts
function fn<T, U>(x: T, y: U) {
  // do something...
}
```

泛型参数默认值：


```ts
function fn<T, U = string>(x: T, y: U) {
  // do something...
}
```

> 有默认值意味着它是可选参数，它必须放在必选参数之后声明，因此 `<T = string, U>` 是错误写法。

泛型参数约束：

```ts
function getLength<T extends {length: number}>(arg: T) {
  return arg.length
}

getLength('abc')
getLength([])
```

未完待续...

## 体操演练场

- [type-challenges](https://github.com/type-challenges/type-challenges)
- [TypeHero](https://typehero.dev/)
- [Advent of TypeScript](https://www.adventofts.com/)
