---
title: 浅谈 TypeScript 泛型
number: '#371'
link: 'https://github.com/toFrankie/blog/issues/371'
created_at: '2025-09-09 18:28:15'
updated_at: '2025-09-10 22:44:03'
labels:
  - TS
  - '2025'
---
## 从一个简单的例子开始

假设你正在开发一个工具库，要实现 id 函数，它接收任意类型的参数并原样返回。

在 JS 中，这很简单：

```js
function id(arg) {
  return arg
}
```

在 TS 中，这个例子不应该使用 `any` 大法，否则会丢失类型检查。那么如何描述参数与返回值的类型关系呢？

最笨的做法是使用函数重载，把可能的类型都列出来：

```ts
function id(arg: number): number
function id(arg: string): string
function id(arg: boolean): boolean
// ...
```

> 这样写下去，没写完就下班了...

类型有无数种（包括复合类型、联合类型等），根本穷举不完。如果希望这个函数足够灵活，这不是一种合理的做法。

我们观察一下，参数 `arg` 的类型实际上只有在函数调用时才能确认。这是不是有点像 JS 函数本身？类型就是形参，实际入参也是在函数调用时才能知道具体值。

如果 TS 的类型支持函数编程就好了，比如：

```ts
// 伪代码
function Id(Arg) {
  return Arg
}
```

> 本文将其称作「类型函数」，其中 `Id` 是类型函数的函数名，`Arg` 为函数类型的形参。而 JS 函数 `id` 称为函数本身。

把类型函数化，也就是说 `Arg` 类型取决于入参的类型。当输入为 `string` 类型，输出也是 `string` 类型，这正是我们需要的。

但这样写有个问题，跟 JS 的函数语法有冲突，实际会被当作一个名为 `Id` 的 JS 函数。所以 TS 需要使用特有的语法来表达，它用的是 `<>` 来代替 `()` 以避免语法冲突，这样编译器就懂得区分类型函数还是函数本身了。比如：

```js
// 伪代码
function Id<Arg> {
  return Arg
}
```

> 历史小故事：由于 TS 比 React 早出生，谁知道后面会有 JSX 横空出世并流行起来，刚开始 TS 跟 JSX 的 `<>` 是有冲突的，直到 [TS 1.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html) 才开始支持 JSX 语法。

最后 TS 是这么干的，它把类型函数和函数本身融合在一起，语法如下：

```ts
function id<Arg>(arg: Arg): Arg {
  return arg
}
```

这样去理解这种语法：

1. 它是由函数本身和类型函数两部分组成。
2. 类型函数的形参在 `<>` 内定义，其作用范围（即函数体）是函数本身的形参类型和返回值类型。
3. 既然是形参，那意味着可以将 `Arg` 命名为其他名称，如 `T`（Type），这样再看是不是很眼熟了。只是大家习惯用 `T` 以及其后面的字母来命名泛型函数的形参，如 `U`、`V` 等，算是一种约定俗成的写法吧。

