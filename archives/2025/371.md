---
title: 浅谈 TypeScript 泛型
number: '#371'
link: 'https://github.com/toFrankie/blog/issues/371'
created_at: '2025-09-09 18:28:15'
updated_at: '2025-09-13 23:20:03'
labels:
  - TS
  - '2025'
---
## 从一个简单的例子开始

假设现在需要给 `id` 函数标注类型，它接收任意类型的参数并原样返回。

```js
function id(arg) {
  return arg
}
```

如何描述参数与返回值的类型关系呢？

较笨的做法是使用函数重载把可能的类型都列出来，但这样写下去，没写完就下班了...

```ts
function id(arg: number): number
function id(arg: string): string
function id(arg: boolean): boolean
// ...
```

类型可以有无数种（包括复合类型、联合类型等），根本穷举不完。

如果希望类型足够灵活，这也不是一种合理的做法。

我们知道，参数 `arg` 的具体值只有在函数调用时才能确认，参数类型也是同样的。

TS 的类型也是支持函数编程的，伪代码如下：

```ts
function Id(Arg) {
  return Arg
}
```

把类型函数化，也就是说 `Arg` 类型取决于函数调用时入参的类型。比如，当输入为 `string` 类型，输出也是 `string` 类型。

但这样写跟 JS 的函数语法有冲突，实际会被当作一个名为 `Id` 的 JS 函数。

TS 需要使用特有的语法来表达类型函数，用的是 `<>`，类似于 JS 函数的 `()`，在其内部声明类型的形参、函数的形参，伪代码如下：

```js
// 伪代码
function Id<Arg> {
  return Arg
}
```

> 历史故事：由于 TS 比 React 早出生，刚开始 TS 跟 JSX 的 `<>` 语法是有冲突的，直到 [TS 1.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html) 才开始支持 JSX。

前面都是伪代码，最后 TS 是这么干的，它把类型函数和函数本身融合在一起，语法如下：

> ⚠️ 注意，「类型函数」只是本文为了让读者更好地理解泛型而使用的一种表述，并非官方定术语。

```ts
function id<Arg>(arg: Arg): Arg {
  return arg
}
```

我们可以这样去解读：

1. 它是由函数本身和类型函数两部分组成。
2. 函数本身和类型函数都可以定义形参，分别在 `()`、`<>` 内定义。
3. 类型函数的形参在 `<>` 内定义，其作用范围（即函数体）是函数本身的形参类型和返回值类型。
4. 因为形参本身也算是一种变量，所以形参的 `Arg` 可以命名为其他合法的变量名。习惯上，`T`（Type）及其后面的字母 `U`、`V` 用得较多，类似于循环遍历常用的 i、j、k 差不多，算是一种约定俗成的写法吧。

改成使用更广泛的 `T`，是不是很眼熟：

```ts
function id<T>(arg: T): T {
  return arg
}
```

得益于 TS 强大的自动类型推断，不显式指定返回值类型也是 OK 的，它可以自动识别返回类型就是 `T`。

```ts
function id<T>(arg: T) {
  return arg
}
```

没错，这就是泛型。
