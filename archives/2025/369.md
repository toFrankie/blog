---
title: 'TypeScript 中 Object、object、{} 之间的区别'
number: '#369'
link: 'https://github.com/toFrankie/blog/issues/369'
created_at: '2025-09-04 18:12:25'
updated_at: '2025-09-04 18:18:51'
labels:
  - TS
  - '2025'
---
![配图源自 Freepik](https://cdn.jsdelivr.net/gh/toFrankie/blog@main/images/2025/9/1756980702601.jpg)

## 写在前面

在 JS 中，构造函数 `Object`、空对象字面量 `{}` 可以作为值使用，因此它俩在 TS 中也可以作为值使用。

在 TS 中，`Object`、`object`、`{}` 还可以作为类型使用。注意 `Object` 和 `object` 是两种不同的类型。还有 `object` 是 TS 特有的类型，只能用于类型，不能作为值。


## 迷之写法 🤯

请问这几种写法有什么不同？它们可以接收哪些值？

```ts
// 1️⃣
const obj = {}

// 2️⃣
const obj: {} = {}

// 3️⃣
const obj: {}

// 4️⃣
const obj: Object

// 5️⃣
const obj: object
```

## object（小 o）

回顾一下，在 JS 中有「基本数据类型」和「引用数据类型」两种数据类型：

- 基本数据类型
    - Number
    - String
    - Boolean
    - Symbol
    - BigInt
    - Undefined
    - Null
- 引用数据类型
    - Object（包括对象、数组、函数、Map、Set、Date 等）

> 注意，以上用大写字母开头的表述形式与 TS 无关，把它换成中文（如字符串类型）也行，别混淆了。

这些数据类型对应的 TS 类型如下：

- 基本数据类型：
    - `number`
    - `string`
    - `boolean`
    - `symbol`
    - `bigint`
    - `undefined`
    - `null`
- 引用数据类型
    - `object`

到这里应该理解了，`object` 表示一个引用值的类型。

```ts
// 所有基本数据类型的类型
type Primitive = number | string | boolean | symbol | bigint | null | undefined

// 所有引用数据类型的类型
type NonPrimitive = object // 相当于 Exclude<unknown, Primitive>
```

示例：只要值是引用值便可以赋值给 `object` 类型的变量。

```ts
let obj: object

obj = 1 // ❌ Type 'number' is not assignable to type 'object'.
obj = 'abc' // ❌ Type 'string' is not assignable to type 'object'.
obj = true // ❌ Type 'boolean' is not assignable to type 'object'.
obj = Symbol('abc') // ❌ Type 'symbol' is not assignable to type 'object'.
obj = 1n // ❌ Type 'bigint' is not assignable to type 'object'.
obj = null // ❌ Type 'null' is not assignable to type 'object'.
obj = undefined // ❌ Type 'undefined' is not assignable to type 'object'.

obj = {} // ✅
obj = Object // ✅
obj = { foo: 123 } // ✅
obj = [1, 2] // ✅
obj = (a: number, b: number) => a + b // ✅
```

虽说可以把任意的引用值赋值给 `obj` 变量，但是其访问属性时，TS 为了确保安全访问，只能访问其包含的类型中都存在的属性，否则要做类型收窄。

```ts
let a: object

a = [] // ✅
a = {} // ✅

a.join(',') // ❌ 像普通对象就没有 join 属性，因此抛出错误 Property 'join' does not exist on type 'object'.
a.toString() // ✅ 共有属性

if (Array.isArray(a)) {
  a.join(',') // ✅ 数组独有的方法
}
```

## Object（大 O）

先从 JS 讲起。我们知道 JS 的原始值是没有任何属性和方法的。

```js
const foo = 'abc'
foo.length // 3
```

那为什么 `foo.length` 不报错呢？原因是内部相当于这样，首先将其转为引用类型，实际读取的是 String 实例对象的 `length` 属性。

```js
const foo = 'abc'
Object(3).length // 3
```

![](https://cdn.jsdelivr.net/gh/toFrankie/blog@main/images/2025/9/1756975794364.png)

但 `undefined`、`null` 这两个家伙无法转为引用类型，因此类似 `undefined.length` 这种会抛出 TypeError。

前面铺垫完之后，再看看示例：

```ts
let obj: Object

obj = 1 // ✅
obj = 1n // ✅
obj = 'abc' // ✅
obj = true // ✅
obj = null // ❌ Type 'null' is not assignable to type 'Object'.
obj = undefined // ❌ Type 'undefined' is not assignable to type 'Object'.
obj = Symbol('abc') // ✅

obj = {} // ✅
obj = Object // ✅
obj = { foo: 123 } // ✅
obj = [1, 2] // ✅
obj = (a: number, b: number) => a + b // ✅
```

任意非 `undefined`、`null` 的值，都可以赋值给 `Object` 类型（指 TS 类型）的变量。

`Object` 表示的类型范围太宽了，实际中应该少用。

## 空对象 {}

在 TS 中，空对象 `{}` 既是一个值，也是一个特殊的类型。

以下两种写法是等价的：

```ts
const obj = {}
const obj: {} = {}
```

> TS 自动推导出 `obj` 的类型是 `{}`，即 `Object`，

以下两种写法是等价的：

```ts
const obj: {}
const obj: Object
```

所以使用 `{}` 作为类型时，它实际上是 `Object` 类型的简写形式。

要注意下，虽然两者形式上有点像，第一个本质上是 `Object` 类型，所以它不会触发对象的严格字面量检查。

```ts
let obj: {} = { a: 1 } // ✅

let obj2: { x: number } = { x: 1, y: 2 } // ❌ Object literal may only specify known properties, and 'y' does not exist in type '{ x: number; }'.
```

## 总结

- `object` 类型的变量仅接受任意引用值。
- `Object` 类型的变量接受除 `undefined` 和 `null` 之外的任意值。
- 将 `{}` 作为类型时，它实际上是 `Object` 类型的简写。即 `const obj: {}` 等价于 `const obj: Object`。

回到文章开头令人抓狂的示例：

```ts
// 1️⃣
const obj = {}

// 2️⃣
const obj: {}

// 3️⃣
const obj: {} = {}

// 4️⃣
const obj: Object

// 5️⃣
const obj: object
```
1️⃣、2️⃣、3️⃣、4️⃣ 为同一类，都是 `Object` 类型，5️⃣ 则是 `object` 类型。

